"""
Report generation utilities
"""

import streamlit as st
import pandas as pd
import io
from datetime import datetime
from typing import Dict, Any, List, Optional
import plotly.graph_objects as go

from config.settings import REPORT_CONFIG
from config.constants import SUCCESS_MESSAGES


class ReportGenerator:
    """Centralized report generation utilities"""
    
    @staticmethod
    def generate_excel_report(data_dict: Dict[str, pd.DataFrame], 
                            filename: str, 
                            metadata: Optional[Dict[str, Any]] = None) -> bytes:
        """Generate Excel report with multiple sheets"""
        try:
            output = io.BytesIO()
            
            with pd.ExcelWriter(output, engine=REPORT_CONFIG["excel_engine"]) as writer:
                # Add metadata sheet if provided
                if metadata:
                    metadata_df = pd.DataFrame.from_dict(metadata, orient='index', columns=['Value'])
                    metadata_df.to_excel(writer, sheet_name='Metadata', index=True)
                
                # Add data sheets
                for sheet_name, df in data_dict.items():
                    if not df.empty:
                        # Sanitize sheet name
                        clean_sheet_name = ReportGenerator._sanitize_sheet_name(sheet_name)
                        df.to_excel(writer, sheet_name=clean_sheet_name, index=False)
                        
                        # Get workbook and worksheet for formatting
                        workbook = writer.book
                        worksheet = writer.sheets[clean_sheet_name]
                        
                        # Apply formatting
                        ReportGenerator._apply_excel_formatting(workbook, worksheet, df)
            
            return output.getvalue()
            
        except Exception as e:
            st.error(f"Error generating Excel report: {str(e)}")
            return bytes()

    @staticmethod
    def generate_html_report(title: str, sections: Dict[str, str], 
                           charts: Optional[Dict[str, go.Figure]] = None) -> str:
        """Generate HTML report with sections and charts"""
        try:
            # HTML template
            html_template = f"""
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>{title}</title>
                <style>
                    body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; color: #333; }}
                    .header {{ text-align: center; border-bottom: 2px solid #004d40; padding-bottom: 20px; margin-bottom: 30px; }}
                    .section {{ margin: 30px 0; page-break-inside: avoid; }}
                    .section-title {{ color: #004d40; border-bottom: 1px solid #ddd; padding-bottom: 10px; }}
                    .chart-container {{ margin: 20px 0; text-align: center; }}
                    table {{ width: 100%; border-collapse: collapse; margin: 15px 0; }}
                    th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                    th {{ background-color: #e6f2f0; }}
                    .footer {{ margin-top: 50px; text-align: center; font-size: 0.9em; color: #666; }}
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>{title}</h1>
                    <p>Generated on: {datetime.now().strftime(REPORT_CONFIG["date_format"])}</p>
                </div>
                
                {ReportGenerator._generate_html_sections(sections)}
                
                {ReportGenerator._generate_html_charts(charts) if charts else ""}
                
                <div class="footer">
                    <p>Generated by Fund Administration Platform</p>
                </div>
            </body>
            </html>
            """
            
            return html_template
            
        except Exception as e:
            st.error(f"Error generating HTML report: {str(e)}")
            return ""

    @staticmethod
    def _sanitize_sheet_name(name: str) -> str:
        """Sanitize Excel sheet name"""
        import re
        # Remove invalid characters and limit length
        sanitized = re.sub(r'[\\/*?:"<>|]', "", name)[:31]
        return sanitized if sanitized else "Sheet1"

    @staticmethod
    def _apply_excel_formatting(workbook, worksheet, df: pd.DataFrame):
        """Apply formatting to Excel worksheet"""
        try:
            # Define formats
            header_format = workbook.add_format({
                'bold': True,
                'text_wrap': True,
                'valign': 'top',
                'fg_color': '#D7E4BD',
                'border': 1
            })
            
            currency_format = workbook.add_format({'num_format': '$#,##0.00'})
            percent_format = workbook.add_format({'num_format': '0.00%'})
            
            # Apply header formatting
            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, header_format)
            
            # Auto-adjust column widths
            for i, col in enumerate(df.columns):
                max_length = max(
                    df[col].astype(str).map(len).max(),
                    len(str(col))
                ) + 2
                worksheet.set_column(i, i, min(max_length, 50))
                
        except Exception as e:
            # Formatting errors shouldn't break report generation
            pass

    @staticmethod
    def _generate_html_sections(sections: Dict[str, str]) -> str:
        """Generate HTML sections"""
        html_sections = ""
        
        for title, content in sections.items():
            html_sections += f"""
            <div class="section">
                <h2 class="section-title">{title}</h2>
                <div class="section-content">{content}</div>
            </div>
            """
        
        return html_sections

    @staticmethod
    def _generate_html_charts(charts: Dict[str, go.Figure]) -> str:
        """Generate HTML chart sections"""
        html_charts = ""
        
        for title, chart in charts.items():
            try:
                chart_html = chart.to_html(full_html=False, include_plotlyjs='cdn')
                html_charts += f"""
                <div class="section">
                    <h2 class="section-title">{title}</h2>
                    <div class="chart-container">{chart_html}</div>
                </div>
                """
            except Exception as e:
                html_charts += f"""
                <div class="section">
                    <h2 class="section-title">{title}</h2>
                    <p>Error generating chart: {str(e)}</p>
                </div>
                """
        
        return html_charts

    @staticmethod
    def create_download_button(data: bytes, filename: str, mime_type: str, 
                             label: str = "Download Report"):
        """Create Streamlit download button with error handling"""
        try:
            st.download_button(
                label=label,
                data=data,
                file_name=filename,
                mime=mime_type
            )
            st.success(SUCCESS_MESSAGES["report_generated"])
            
        except Exception as e:
            st.error(f"Error creating download button: {str(e)}")


class ChartGenerator:
    """Utility functions for generating common chart types"""
    
    @staticmethod
    def create_metric_cards_html(metrics: Dict[str, str]) -> str:
        """Create HTML metric cards"""
        cards_html = '<div style="display: flex; flex-wrap: wrap; gap: 20px;">'
        
        for label, value in metrics.items():
            cards_html += f"""
            <div style="border: 1px solid #ddd; border-radius: 8px; padding: 20px; 
                        flex: 1; min-width: 200px; text-align: center; background: #f9f9f9;">
                <div style="font-size: 0.9em; color: #666; margin-bottom: 10px;">{label}</div>
                <div style="font-size: 1.5em; font-weight: bold; color: #333;">{value}</div>
            </div>
            """
        
        cards_html += '</div>'
        return cards_html